/*
Contributors: Pratek Vij, Sagar Manchanda
A syntax parser for SQL language. The primary function is 'parse'.
The function reads the file 'lex.txt' which contains the list of tokens generated by the tokeniser.
The function then parse the tokens and throws an error in case of invalid syntax.
If the syntax is valid, it builds a parse tree.
*/
#include "syntax.h"
#include <bits/stdc++.h>
using namespace std;

int tokens_read = 0;
int error = -1;
int token_array[MAX_TOKENS_PER_INPUT];

char dict[55][20];

int num_nodes = 0;
vector<string> node_name;
vector<pair<int,int> > edges;
bool token_error = false;

// Custom comparator for parse tree printing
bool customComparator(pair<int,int> a, pair<int,int> b){
    if(a.first == b.first){
        return (a.second<b.second);
    }
    return (a.first<b.first);
}


// Parse the token array passed by tokeniser and create the parse tree
int parse(){
    create_dict(dict);
    FILE *fp = fopen("lex.txt", "r");

    while(!feof(fp)){

        char *input = (char*)malloc(MAX_INPUT_SIZE*sizeof(char));
        fgets(input, 1024, fp);
        token_error = false;


        int i, input_len = strlen(input)-1;

        int num_token = 0;
        char *temp = strtok(input, " \n");

        while(temp != NULL){
            token_array[num_token] = atoi(temp);
            num_token++;
            temp = strtok(NULL, " \n");
        }


        tokens_read = 0;
        error = false;

        if (num_token == 0)
        {
            exit(0);
            continue;
        }
        // printf("Token Count %d\n",num_token );


        if(S() && tokens_read == num_token){
            printf("\n\n## Accepted\n\n");
        }
        else{
            printf("\n\n## Rejected\n\n");
            continue;
        }
        ;


        int len = edges.size();
        sort(edges.begin(), edges.end(), customComparator);


        map<int,int> level;
        map<int,int> order;
        map<int,int> marked;

        int counted = 0;

        level[0] = 0;
        int itr;
        for(itr=0;itr<len;itr++){
            if(marked.find(edges[itr].second) == marked.end()){
                marked[edges[itr].second] = 1;
                order[counted] = edges[itr].second;
                int k = edges[itr].second;
                counted++;
            }
            if(level.find(edges[itr].first) == level.end()){
                level[edges[itr].first] = level[edges[itr].second]+1;
            }
        }

        for(i=0;i<counted;i++){

            for(int j=0;j<level[order[i]];j++){ cout << "\t" ; }

            cout << node_name[order[i]] << " :: ";
            
            for(int j=0;j<len;j++){ if(edges[j].second == order[i]){ cout << node_name[edges[j].first] << " "; } }

            cout << endl;

        }


        num_nodes = 0;
        node_name.clear();
        edges.clear();
    }    



    return 0;
}


// Match the token for terminals
bool match(int x){

    if(token_array[tokens_read] == x){
        // printf("P %s\n",dict[x]);
        tokens_read++;
        return true;
    }
    else{
        if (x == -1)
        {
            token_error = true;
        }
        error = max(error, tokens_read);
        return false;
    }
}


// Utility functions for printing the parse tree
int add_node(string s){
    num_nodes++;
    node_name.push_back(s);
    return num_nodes-1;
}

void add_edge(int i, int j){
    edges.push_back(make_pair(i,j));
}



// PRODUCTION RULES , Start symbol = S
/*            RULES begin           */

bool S(){
    int parent = add_node("S");
    int current_read = tokens_read;
    
    int node_id_c0 = add_node("C_0");
    if(C_0(node_id_c0)){
        add_edge(node_id_c0, parent);
        return true;
    }
    tokens_read = current_read;    
    
    int node_id_i0 = add_node("I_0");
    if(I_0(node_id_i0)){
        add_edge(node_id_i0, parent);
        return true;
    }
    tokens_read = current_read;
    
    int node_id_s13 = add_node("S_13");
    if(S_13(node_id_s13)){
        add_edge(node_id_s13, parent);
        return true;
    }
    
    tokens_read = current_read;
    
    int node_id_d0 = add_node("D_0");
    if(D_0(node_id_d0)){
        add_edge(node_id_d0, parent);
        return true;
    }
    
    tokens_read = current_read;
    
    int node_id_b0 = add_node("B_0");
    if(B_0(node_id_b0)){
        add_edge(node_id_b0, parent);
        return true;
    }
    
    tokens_read = current_read;
    
    int node_id_u0 = add_node("U_0");
    if(U_0(node_id_u0)){
        add_edge(node_id_u0, parent);
        return true;
    }
    

    tokens_read = current_read;
    int node_id_a0 = add_node("A_0");
    if(A_0(node_id_a0)){
        add_edge(node_id_a0, parent);
        return true;
    }
    
    tokens_read = current_read;
    if (match(SEMICOLON))
    {
    	add_edge(add_node("SEMICOLON"), parent);
    	return true;
    }

    tokens_read = current_read;
    syntax_error();
    return false;
}


bool A_0(int parent){
	int current_read = tokens_read;
	int node_id_alter=add_node("ALTER"), node_id_table=add_node("TABLE"), node_id_id=add_node("ID"), node_id_a1=add_node("A1"), node_id_semicolon=add_node("SEMICOLON");
    if (match(ALTER) && match(TABLE) && match(ID) && A_1(node_id_a1) && match(SEMICOLON)){
        add_edge(node_id_alter, parent);
        add_edge(node_id_table, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_a1, parent);
        add_edge(node_id_semicolon, parent);
        return true;
    }

    tokens_read = current_read;
    return false;
}

bool A_1(int parent){
	int current_read = tokens_read;
	int node_id_drop=add_node("DROP"), node_id_column=add_node("COLUMN"), node_id_id=add_node("ID");
    if (match(DROP) && match(COLUMN) && match(ID)){
        add_edge(node_id_drop, parent);
        add_edge(node_id_column, parent);
        add_edge(node_id_id, parent);
        return true;
    }

    tokens_read = current_read;
    int node_id_add=add_node("ADD"), node_id_c1=add_node("C_1");
    if (match(ADD) && C_1(node_id_c1)){
        add_edge(node_id_add, parent);
        add_edge(node_id_c1, parent);
        return true;
    }

    tokens_read = current_read;
    return false;
} 

bool C_0(int parent){

    int current_read = tokens_read;
    if (match(CREATE) && match(DATABASE) && match(ID) && match(SEMICOLON)){
        add_edge(add_node("CREATE"), parent);
        add_edge(add_node("DATABASE"), parent);
        add_edge(add_node("ID"), parent);
        add_edge(add_node("SEMICOLON"), parent);
        return true;
    }

    tokens_read = current_read;

    int node_id_create=add_node("CREATE"), node_id_table=add_node("TABLE"), node_id_id=add_node("ID"), node_id_lp=add_node("LP"), node_id_c1 = add_node("C_1"), node_id_rp=add_node("RP"), node_id_semicolon=add_node("SEMICOLON");
    if (match(CREATE) && match(TABLE) && match(ID) && match(LP) && C_1(node_id_c1) && match(RP) && match(SEMICOLON)){
        add_edge(node_id_create, parent);
        add_edge(node_id_table, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_lp, parent);
        add_edge(node_id_c1, parent);
        add_edge(node_id_rp, parent);
        add_edge(node_id_semicolon, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("C_0 failed\n");
    return false;
}

bool C_1(int parent){

    int current_read = tokens_read;

    int node_id_id = add_node("ID"), node_id_c4 = add_node("C_4"), node_id_c2 = add_node("C_2"), node_id_c3 = add_node("C_3");
    if (match(ID) && C_4(node_id_c4) && C_2(node_id_c2) && C_3(node_id_c3)){
        add_edge(node_id_id, parent);
        add_edge(node_id_c4, parent);
        add_edge(node_id_c2, parent);
        add_edge(node_id_c3, parent);
        return true;
    }
    tokens_read = current_read;
    // printf("C_1 failed\n");
    return false;  
}

bool C_2(int parent){

    int current_read = tokens_read;

    int node_id_constraint=add_node("CONSTRAINT"), node_id_c2 = add_node("C_2");
    if (match(CONSTRAINT) && C_2(node_id_c2))
    {   
        add_edge(node_id_constraint, parent);
        add_edge(node_id_c2, parent);
        return true;
    }
    
    tokens_read = current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool C_3(int parent){

    int current_read = tokens_read;

    int node_id_comma = add_node("COMMA"), node_id_c1 = add_node("C_1"), node_id_c3 = add_node("C_3");
    if (match(COMMA) && C_1(node_id_c1) && C_3(node_id_c3)){
        add_edge(node_id_comma, parent);
        add_edge(node_id_c1, parent);
        add_edge(node_id_c3, parent);
        return true;
    }

    tokens_read =current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;   
}

bool C_4(int parent){

    int current_read = tokens_read;
    
    int node_id_c5 = add_node("C_5");
    if(C_5(node_id_c5)){ 
       add_edge(node_id_c5, parent);
       return true;
    }

    tokens_read = current_read;
    
    int node_id_c6 = add_node("C_6");
    if(C_6(node_id_c6)){ 
        add_edge(node_id_c6, parent);
        return true;
    }
    
    tokens_read = current_read;
    
    int node_id_c7 = add_node("C_7");
    if(C_7(node_id_c7)){ 
        add_edge(node_id_c7, parent);
        return true;
    }
    
    tokens_read = current_read;
    
    int node_id_c8 = add_node("C_8");
    if(C_8(node_id_c8)){ 
        add_edge(node_id_c8, parent);
        return true;
    }
    
    tokens_read = current_read;
    // printf("C_4 failed\n");
    return false;
}

bool C_5(int parent){

    int current_read = tokens_read;
    
    if (match(COL_TYPE1))
    {
        add_edge(add_node("COL_TYPE1"), parent);
        return true;
    }

    tokens_read = current_read;
    // printf("C_5 failed\n");
    return false;
}

bool C_6(int parent){
   
    int current_read = tokens_read;
    if (match(COL_TYPE2) && match(LP) && match(INTEGER) && match(RP))
    {
        add_edge(add_node("COL_TYPE2"), parent);
        add_edge(add_node("LP"), parent);
        add_edge(add_node("INTEGER"), parent);
        add_edge(add_node("RP"), parent);
        return true;
    }

    tokens_read = current_read;
    // printf("C_6 failed\n");
    return false;
}

bool C_7(int parent){
 

    int current_read = tokens_read;
    
    int node_id_coltype3 = add_node("COL_TYPE3"), node_id_c9 = add_node("C_9");
    if (match(COL_TYPE3) && C_9(node_id_c9))
    {   
        add_edge(node_id_coltype3, parent);
        add_edge(node_id_c9, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("C_7 failed\n");
    return false;
    
}

bool C_8(int parent){
   

    int current_read = tokens_read;
    
    int node_id_coltype4 = add_node("COL_TYPE4"), node_id_c10 = add_node("C_10");
    if (match(COL_TYPE4) && C_10(node_id_c10))
    {   
        add_edge(node_id_coltype4, parent);
        add_edge(node_id_c10, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("C_8 failed\n");
    return false;
    
}

bool C_9(int parent){
    

    int current_read = tokens_read;
    if (match(LP) && match(INTEGER) && match(RP))
    {
        add_edge(add_node("LP"), parent);
        add_edge(add_node("INTEGER"), parent);
        add_edge(add_node("RP"), parent);
        return true;
    }

    tokens_read = current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool C_10(int parent){

    int current_read = tokens_read;
    
    int node_id_lp = add_node("LP"), node_id_c11 = add_node("C_11"), node_id_rp = add_node("RP");
    if (match(LP) && match(INTEGER) && C_11(node_id_c11) && match(RP))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_c11, parent);
        add_edge(node_id_rp, parent);
        return true;
    }

    tokens_read = current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool C_11(int parent){

    int current_read = tokens_read;
    if (match(COMMA) && match(INTEGER))
    {   
        add_edge(add_node("COMMA"), parent);
        add_edge(add_node("INTEGER"), parent);
        return true;
    }

    tokens_read = current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;

}

bool I_0(int parent) {
    int current_read = tokens_read;
    
    int node_id_insert = add_node("INSERT"), node_id_into = add_node("INTO") , node_id_id = add_node("ID"), node_id_i1 = add_node("I_1"), node_id_values = add_node("VALUES"), node_id_lp = add_node("LP"), node_id_i2 = add_node("I_2"), node_id_rp = add_node("RP"), node_id_semicolon = add_node("SEMICOLON"); 
    if (match(INSERT) && match(INTO) && match(ID) && I_1(node_id_i1) && match(VALUES) && match(LP) && I_2(node_id_i2) && match(RP) && match(SEMICOLON))
    {   
        add_edge(node_id_insert, parent);
        add_edge(node_id_into, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_i1, parent);
        add_edge(node_id_values, parent);
        add_edge(node_id_lp, parent);
        add_edge(node_id_i2, parent);
        add_edge(node_id_rp, parent);
        add_edge(node_id_semicolon, parent);
        return true;

    }

    tokens_read = current_read;
    // printf("I_0 failed\n");
    return false;
}

bool I_1(int parent) {
    int current_read = tokens_read;
    
    int node_id_lp = add_node("LP"), node_id_id = add_node("ID"), node_id_i3 = add_node("I_3"), node_id_rp = add_node("RP");
    if (match(LP) && match(ID) && I_3(node_id_i3) && match(RP))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_i3, parent);
        add_edge(node_id_rp, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("epsilon in I1, pointer back to %d\n", tokens_read);
    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool I_2(int parent) {
    int current_read = tokens_read;
    
    int node_id_literal = add_node("LITERAL"), node_id_i4 = add_node("I_4");
    if (match(LITERAL) && I_4(node_id_i4))
    {   
        add_edge(node_id_literal, parent);
        add_edge(node_id_i4, parent);
        return true;
    }

    tokens_read = current_read;
    
    int node_id_integer = add_node("INTEGER"); node_id_i4 = add_node("I_4");
    if (match(INTEGER) && I_4(node_id_i4))
    {   
        add_edge(node_id_integer, parent);
        add_edge(node_id_i4, parent);
        return true;
    }

    tokens_read = current_read;
    
    int node_id_float = add_node("FLOAT"); node_id_i4 = add_node("I_4");
    if (match(FLOAT) && I_4(node_id_i4))
    {   
        add_edge(node_id_float, parent);
        add_edge(node_id_i4, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("I_2 failed\n");
    return false;
}

bool I_3(int parent) {
    int current_read = tokens_read;
    
    int node_id_comma = add_node("COMMA"), node_id_id = add_node("ID"), node_id_i3 = add_node("I_3");
    if (match(COMMA) && match(ID) && I_3(node_id_i3))
    {   
        add_edge(node_id_comma, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_i3, parent);
        return true;
    }

    tokens_read = current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool I_4(int parent) {
    int current_read = tokens_read;
    
    int node_id_comma = add_node("COMMA"), node_id_literal = add_node("LITERAL"), node_id_i4 = add_node("I_4");
    if (match(COMMA) && match(LITERAL) && I_4(node_id_i4))
    {
        add_edge(node_id_comma, parent);
        add_edge(node_id_literal, parent);
        add_edge(node_id_i4, parent);
        return true;
    }

    tokens_read = current_read;

    node_id_comma = add_node("COMMA"); int node_id_integer = add_node("LITERAL"); node_id_i4 = add_node("I_4");
    if (match(COMMA) && match(INTEGER) && I_4(node_id_i4))
    {
        add_edge(node_id_comma, parent);
        add_edge(node_id_integer, parent);
        add_edge(node_id_i4, parent);
        return true;
    }

    tokens_read = current_read;

    node_id_comma = add_node("COMMA"); int node_id_float = add_node("FLOAT"); node_id_i4 = add_node("I_4");
    if (match(COMMA) && match(FLOAT) && I_4(node_id_i4))
    {
        add_edge(node_id_comma, parent);
        add_edge(node_id_float, parent);
        add_edge(node_id_i4, parent);
        return true;
    }

    tokens_read = current_read;
    
    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool D_0(int parent) {
    int current_read = tokens_read;
    
    if (match(DROP) && match(TABLE) && match(ID) && match(SEMICOLON))
    {
        add_edge(add_node("DROP"), parent);
        add_edge(add_node("TABLE"), parent);
        add_edge(add_node("ID"), parent);
        add_edge(add_node("SEMICOLON"), parent);
        return true;
    }

    tokens_read = current_read;
    if (match(DROP) && match(DATABASE) && match(ID) && match(SEMICOLON))
    {
        add_edge(add_node("DROP"), parent);
        add_edge(add_node("DATABASE"), parent);
        add_edge(add_node("ID"), parent);
        add_edge(add_node("SEMICOLON"), parent);
        return true;
    }

    tokens_read = current_read;
    // printf("D_0 failed\n");
    return false;   
}

bool B_0(int parent) {
    int current_read = tokens_read;

    int node_id_delete = add_node("DELETE"), node_id_from = add_node("FROM"), node_id_id = add_node("ID"), node_id_s3 = add_node("S_3"), node_id_semicolon = add_node("SEMICOLON");
    if (match(DELETE) && match(FROM) && match(ID) && S_3(node_id_s3) && match(SEMICOLON))
    {
        add_edge(node_id_delete, parent);
        add_edge(node_id_from, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_s3, parent);
        add_edge(node_id_semicolon, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("B_0 failed\n");
    return false;   
}

bool S_0(int parent) {
    int current_read = tokens_read;

    int node_id_select = add_node("SELECT"), node_id_s1 = add_node("S_1"), node_id_from = add_node("FROM"), node_id_s2 = add_node("S_2"), node_id_s3 = add_node("S_3"), node_id_s4 = add_node("S_4");
    if (match(SELECT) && S_1(node_id_s1) && match(FROM) && S_2(node_id_s2) && S_3(node_id_s3) && S_4(node_id_s4) )
    {
        add_edge(node_id_select, parent);
        add_edge(node_id_s1, parent);
        add_edge(node_id_from, parent);
        add_edge(node_id_s2, parent);
        add_edge(node_id_s3, parent);
        add_edge(node_id_s4, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("S_0 failed\n");
    return false;
}

bool S_1(int parent) {
    int current_read = tokens_read;
    if (match(WILDCARD))
    {
        add_edge(add_node("WILDCARD"), parent);
        return true;
    }

    tokens_read = current_read;
    
    int node_id_l0 = add_node("L_0");
    if (L_0(node_id_l0))
    {
        // printf("S1 prod 2\n");
        add_edge(node_id_l0, parent);
        return true;
    }

    tokens_read = current_read;
    printf("S_1 failed\n");
    return false;   
}

bool S_2(int parent) {
    int current_read = tokens_read;

    int node_id_s7 = add_node("S_7"), node_id_s10 = add_node("S_10"), node_id_s8 = add_node("S_8");
    if (S_7(node_id_s7) && S_10(node_id_s10) && S_8(node_id_s8))
    {
        add_edge(node_id_s7, parent);
        add_edge(node_id_s10, parent);
        add_edge(node_id_s8, parent);
        return true;
    }

    tokens_read = current_read;

    int node_id_lp = add_node("LP"), node_id_s2 = add_node("S_2"), node_id_rp = add_node("RP"); 
    if (match(LP) && L_0(node_id_s2) && match(RP))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_s2, parent);
        add_edge(node_id_rp, parent);
        return true;
    }

    tokens_read = current_read;

    // printf("S_2 failed\n");
    return false;   
}


bool S_3(int parent) {
    int current_read = tokens_read;
    
    int node_id_where = add_node("WHERE"), node_id_w0 = add_node("W_0");
    if (match(WHERE) && W_0(node_id_w0))
    {
        // printf("S3 prod 1\n");
        add_edge(node_id_where, parent);
        add_edge(node_id_w0, parent);
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool S_4(int parent) {
    
    
    int current_read = tokens_read;
    
    int node_id_order = add_node("ORDER"), node_id_by = add_node("BY"), node_id_asc = add_node("ASC");
    if (match(ORDER) && match(BY) && match(ASC))
    {
        // printf("S4 prod 1\n");
        add_edge(node_id_order, parent);
        add_edge(node_id_by, parent);
        add_edge(node_id_asc, parent);
        return true;
    }

    tokens_read = current_read;

    if (match(ORDER) && match(BY) && match(DESC))
    {
        // printf("S4 prod 1\n");
        add_edge(add_node("ORDER"), parent);
        add_edge(add_node("BY"), parent);
        add_edge(add_node("DESC"), parent);
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool S_7(int parent) {
    int current_read = tokens_read;
    
    int node_id_lp = add_node("LP"), node_id_s7 = add_node("S_7"), node_id_s10 = add_node("S_10"), node_id_rp = add_node("RP"), node_id_s11 = add_node("S_11");
    if (match(LP) && S_7(node_id_s7) && S_10(node_id_s10) && match(RP) && S_11(node_id_s11))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_s7, parent);
        add_edge(node_id_s10, parent);
        add_edge(node_id_rp, parent);
        add_edge(node_id_s11, parent);
        // printf("S7 prod 1\n");
        return true;
    }

    tokens_read = current_read;
    
    int node_id_id = add_node("ID"); node_id_s10 = add_node("S_10"); node_id_s11 = add_node("S_11");
    if (match(ID) && S_10(node_id_s10) && S_11(node_id_s11))
    {
        add_edge(node_id_id, parent);
        add_edge(node_id_s10, parent);
        add_edge(node_id_s11, parent);
        // printf("S7 prod 2\n");
        return true;
    }

    tokens_read = current_read;
    
    int node_id_s0 = add_node("S_0"); node_id_s10 = add_node("S_10"); node_id_s11 = add_node("S_11");
    if (S_0(node_id_s0) && S_10(node_id_s10) && S_11(node_id_s11))
        // printf("S7 prod 3\n");
    {
        add_edge(node_id_s0, parent);
        add_edge(node_id_s10, parent);
        add_edge(node_id_s11, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("S_7 failed\n");
    return false;   
}


bool S_8(int parent) {
    int current_read = tokens_read;
    
    int node_id_comma = add_node("COMMA"), node_id_s7 = add_node("S_7"), node_id_s10 = add_node("S_10"), node_id_s8 = add_node("S_8");
    if (match(COMMA) && S_7(node_id_s7) && S_10(node_id_s10) && S_8(node_id_s8))
    {   
        add_edge(node_id_comma, parent);
        add_edge(node_id_s7, parent);
        add_edge(node_id_s10, parent);
        add_edge(node_id_s8, parent);
        // printf("S8 prod 1\n");
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;   
}

bool S_10(int parent) {
    int current_read = tokens_read;
    if (match(AS) && match(ID))
    {
        add_edge(add_node("AS"), parent);
        add_edge(add_node("ID"), parent);
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;   
}

bool S_11(int parent) {
    int current_read = tokens_read;
    
    int node_id_s14 = add_node("S_14"), node_id_join = add_node("JOIN"), node_id_s7 = add_node("S_7"), node_id_s10 = add_node("S_10"), node_id_s12 = add_node("S_12"), node_id_s11 = add_node("S_11");
    if (S_14(node_id_s14) && match(JOIN) && S_7(node_id_s7) && S_10(node_id_s10) && S_12(node_id_s12) && S_11(node_id_s11))
    {
        // printf("S11 prod 1\n");
        add_edge(node_id_s14, parent);
        add_edge(node_id_join, parent);
        add_edge(node_id_s7, parent);
        add_edge(node_id_s10, parent);
        add_edge(node_id_s12, parent);
        add_edge(node_id_s11, parent);
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;   
}

bool S_12(int parent) { // INCOMPLETE
    // printf("S12\n");

    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool S_13(int parent){

    int current_read = tokens_read;
    
    int node_id_s0 = add_node("S_0"), node_id_semicolon = add_node("SEMICOLON");
    if (S_0(node_id_s0) && match(SEMICOLON))
    {
        add_edge(node_id_s0, parent);
        add_edge(node_id_semicolon, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("S_13 failed\n");
    return false;
}

bool S_14(int parent){
	int current_read = tokens_read;
    
    int node_id_natural = add_node("NATURAL");
    if (match(NATURAL))
    {
        add_edge(node_id_natural, parent);
        return true;
    }

    tokens_read = current_read;
    int node_id_inner = add_node("INNER");
    if (match(INNER))
    {
        add_edge(node_id_inner, parent);
        return true;
    }

    tokens_read = current_read;
    int node_id_outer = add_node("OUTER");
    if (match(OUTER))
    {
        add_edge(node_id_outer, parent);
        return true;
    }

    tokens_read = current_read;
    add_edge(add_node("EPSILON"), parent);
    // printf("S_13 failed\n");
    return true;	
}


bool W_0(int parent) {
    int current_read = tokens_read;
    
    int node_id_w0 = add_node("W_0"), node_id_w3 = add_node("W_3");
    if (W_1(node_id_w0) && W_3(node_id_w3))
    {   
        add_edge(node_id_w0, parent);
        add_edge(node_id_w3, parent);
        return true;
    }

    tokens_read = current_read;

    int node_id_lp = add_node("LP"); node_id_w0 = add_node("W_0"); int node_id_rp = add_node("RP"); node_id_w3 = add_node("W_3");
    if (match(LP) && W_0(node_id_w0) && match(RP) && W_3(node_id_w3))
    {   
        add_edge(node_id_lp, parent);
        add_edge(node_id_w0, parent);
        add_edge(node_id_rp, parent);
        add_edge(node_id_w3, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("W_0 failed\n");
    return false;
}

bool W_1(int parent) {
    int current_read = tokens_read;

    int node_id_e1_1 = add_node("E_1"), node_id_comp = add_node("COMPARATOR"), node_id_e1_2 = add_node("E_1");
    if (E_1(node_id_e1_1) && match(COMPARATOR) && E_1(node_id_e1_2))
    {
        add_edge(node_id_e1_1, parent);
        add_edge(node_id_comp, parent);
        add_edge(node_id_e1_2, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("W_1 failed\n");
    return false;
}


bool W_3(int parent) {
    int current_read = tokens_read;
    
    int node_id_conj = add_node("CONJ"), node_id_w0 = add_node("W_0"), node_id_w3 = add_node("W_3");
    if (match(CONJ) && W_0(node_id_w0) && W_3(node_id_w3))
    {
        add_edge(node_id_conj, parent);
        add_edge(node_id_w0, parent);
        add_edge(node_id_w3, parent);
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool E_0(int parent) {
    int current_read = tokens_read;
    if (match(WILDCARD))
    {   
        add_edge(add_node("WILDCARD"), parent);
        return true;
    }

    tokens_read = current_read;
    
    int node_id_e1 = add_node("E_1");
    if (E_1(node_id_e1))  
    {
        add_edge(node_id_e1, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("E_0 failed\n");
    return false;   
}

bool E_1(int parent) {
    // printf("E_1 called\n");
    int current_read = tokens_read;
    
    int node_id_e2 = add_node("E_2"), node_id_e3 = add_node("E_3");
    if (E_2(node_id_e2) && E_3(node_id_e3))
    {   
        add_edge(node_id_e2, parent);
        add_edge(node_id_e3, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("E_1 failed\n");
    return false;   
}

bool E_2(int parent) {
    // printf("E_2 called\n");
    int current_read = tokens_read;
    
    int node_id_e4 = add_node("E_4"), node_id_e5 = add_node("E_5");
    if (E_4(node_id_e4) && E_5(node_id_e5))
    {
        add_edge(node_id_e4, parent);
        add_edge(node_id_e5, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("E_2 failed\n");
    return false;   
}

bool E_3(int parent) {
    // printf("E_3 called\n");
    int current_read = tokens_read;
    
    int node_id_opt1 = add_node("OPT1"), node_id_e1 = add_node("E_1");
    if (match(OPT1) && E_1(node_id_e1))
    {
        add_edge(node_id_opt1, parent);
        add_edge(node_id_e1, parent);
        return true;
    }

    tokens_read = current_read;
    printf("E_3 eps\n");

    add_edge(add_node("EPSILON"), parent);
    return true;
}

bool E_4(int parent) {
    // printf("E_4 called\n");
    int current_read = tokens_read;
    
    if (match(INTEGER))
    {
        add_edge(add_node("INTEGER"), parent);
        return true;
    }

    tokens_read = current_read;
    if (match(FLOAT))
    {
        add_edge(add_node("FLOAT"), parent);
        return true;
    }

    tokens_read = current_read;
    if (match(ID))
    {
        add_edge(add_node("ID"), parent);
        return true;
    }

    tokens_read = current_read;
    if (match(LITERAL))
    {
        add_edge(add_node("LITERAL"), parent);
        return true;
    }

    tokens_read= current_read;
    
    int node_id_lp = add_node("LP"), node_id_e1 = add_node("E_1"), node_id_rp = add_node("RP");
    if (match(LP) && E_1(node_id_e1) && match(RP))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_e1, parent);
        add_edge(node_id_rp, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("E_4 failed\n");
    return false;   
}

bool E_5(int parent) {
    // printf("E_5 called\n");
    int current_read = tokens_read;
    
    int node_id_opt2 = add_node("OPT2"), node_id_e2 = add_node("E_2");
    if (match(OPT2) && E_2(node_id_e2))
    {
        add_edge(node_id_opt2, parent);
        add_edge(node_id_e2, parent);
        return true;
    }

    tokens_read = current_read;
    printf("E_5 eps\n");

    add_edge(add_node("EPSILON"), parent);
    return true;
}


bool L_0(int parent) {
    int current_read = tokens_read;
    
    int node_id_l1 = add_node("L_1"), node_id_l2 = add_node("L_2");
    if (L_1(node_id_l1) && L_2(node_id_l2))
    {
        add_edge(node_id_l1, parent);
        add_edge(node_id_l2, parent);
        return true;
    }

    tokens_read = current_read;

    int node_id_lp = add_node("LP"), node_id_l0 = add_node("L_0"), node_id_rp = add_node("RP"); 
    if (match(LP) && L_0(node_id_l0) && match(RP))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_l0, parent);
        add_edge(node_id_rp, parent);
        return true;
    }

    tokens_read = current_read;

    // printf("L_0 failed\n");
    return false;   
}

bool L_1(int parent) {
    int current_read = tokens_read;
    
    int node_id_e0 = add_node("E_0"), node_id_l3 = add_node("L_3");
    if (E_0(node_id_e0) && L_3(node_id_l3))
    {
        add_edge(node_id_e0, parent);
        add_edge(node_id_l3, parent);
        return true;
    }

    tokens_read = current_read;
    
    int node_id_lp = add_node("LP"), node_id_l1 = add_node("L_1"), node_id_rp = add_node("RP"); node_id_l3 = add_node("L_3");
    if (match(LP) && L_1(node_id_l1) && match(RP) && L_3(node_id_l3))
    {
        add_edge(node_id_lp, parent);
        add_edge(node_id_l1, parent);
        add_edge(node_id_rp, parent);
        add_edge(node_id_l3, parent);
        return true;
    }

    tokens_read = current_read;
    int node_id_aggr = add_node("AGGR"); node_id_lp = add_node("LP"), node_id_l1 = add_node("L_1"), node_id_rp = add_node("RP"); node_id_l3 = add_node("L_3");
    if (match(AGGR) && match(LP) && L_1(node_id_l1) && match(RP) && L_3(node_id_l3))
    {
        add_edge(node_id_aggr, parent);
        add_edge(node_id_lp, parent);
        add_edge(node_id_l1, parent);
        add_edge(node_id_rp, parent);
        add_edge(node_id_l3, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("L_1 failed\n");
    return false;   
}

bool L_2(int parent) {
    int current_read = tokens_read;
    
    int node_id_comma = add_node("COMMA"), node_id_l1 = add_node("L_1"), node_id_l2 = add_node("L_2");
    if (match(COMMA) && L_1(node_id_l1) && L_2(node_id_l2))
    {
        add_edge(node_id_comma, parent);
        add_edge(node_id_l1, parent);
        add_edge(node_id_l2, parent);
        return true;
    }

    tokens_read = current_read;

    add_edge(add_node("EPSILON"), parent);
    return true;   
}

bool L_3(int parent) {
    int current_read = tokens_read;
    if (match(AS) && match(ID))
    {
        add_edge(add_node("AS"), parent);
        add_edge(add_node("ID"), parent);
        return true;
    }

    tokens_read = current_read;
    printf("L_3 failed\n");
    return true;   
}

bool U_0(int parent) {
    int current_read = tokens_read;
    
    int node_id_update = add_node("UPDATE"), node_id_id1 = add_node("ID"), node_id_set = add_node("SET"), node_id_id2 = add_node("ID"), node_id_comp = add_node("COMPARATOR"), node_id_e1 = add_node("E_1"), node_id_u1 = add_node("U_1"), node_id_s3 = add_node("S_3"), node_id_semicolon = add_node("SEMICOLON");
    if (match(UPDATE) && match(ID) && match(SET) && match(ID) && match(COMPARATOR) && E_1(node_id_e1) && U_1(node_id_u1) && S_3(node_id_s3) && match(SEMICOLON))
    {
        add_edge(node_id_update, parent);
        add_edge(node_id_id1, parent);
        add_edge(node_id_set, parent);
        add_edge(node_id_id2, parent);
        add_edge(node_id_comp, parent);
        add_edge(node_id_e1, parent);
        add_edge(node_id_u1, parent);
        add_edge(node_id_s3, parent);
        add_edge(node_id_semicolon, parent);
        return true;
    }

    tokens_read = current_read;
    // printf("U_0 failed\n");
    return false;   
}


bool U_1(int parent) {
    int current_read = tokens_read;
    
    int node_id_comma = add_node("COMMA"), node_id_id = add_node("ID"), node_id_comp = add_node("COMPARATOR"), node_id_e1 = add_node("E_1"), node_id_u1 = add_node("U_1"); 
    if (match(COMMA) && match(ID) && match(COMPARATOR) && E_1(node_id_e1) && U_1(node_id_u1))
    {
        add_edge(node_id_comma, parent);
        add_edge(node_id_id, parent);
        add_edge(node_id_comp, parent);
        add_edge(node_id_e1, parent);
        add_edge(node_id_u1, parent);
        return true;
    }

    tokens_read = current_read;
    printf("U_0 failed\n");
    add_edge(add_node("EPSILON"), parent);
    return true;   
}

// GRAMMER RULES END        


// Syntax error detection
void syntax_error(){
    if (error>=0)
    {
    	if (token_array[error]==-1)
    	{
    		printf("\nSyntax Error : Unexpected token after token type \"%s\" in the syntax \n",dict[token_array[error-1]] );
    	}
    	else{
    		printf("\nSyntax Error : Unexpected token type \"%s\" after \"%s\" in the syntax \n",dict[token_array[error]],dict[token_array[error-1]] );	
    	}
        
    }
    
    return;
}